//#define DIAG
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace R.FastEndpoints.Generators;

[Generator]
public class ImplicitErrorSendingGenerator : IIncrementalGenerator
{
    const string DontRegisterAttribute = "DontRegisterAttribute";
    static readonly string[] ImplicitSenders = ["SendErrorsAsync", "ThrowError", "ThrowIfAnyErrors"];
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assemblyProvider = context.CompilationProvider
            .Select(static (c, _) => c.AssemblyName)
            .WithTrackingName("AssemblyName");
        
#if DIAG
        var diagnosticsProvider = context.CompilationProvider
            .Select(static (compilation, _) => compilation.GetDiagnostics())
            .WithTrackingName("CompilationDiagnostics");
        
        context.RegisterSourceOutput(diagnosticsProvider, static (ctx, diagnostics) =>
        {
            foreach (var diagnostic in diagnostics.Where(diagnostic => diagnostic.Severity == DiagnosticSeverity.Error))
            {
                ctx.ReportDiagnostic(diagnostic);
            }
        });
#endif
        
        var implicitSendersProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, _) => node is ClassDeclarationSyntax { TypeParameterList: null, BaseList: { Types: { Count: > 0 } } },
                (ctx, _) =>
                {
                    if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) is not INamedTypeSymbol node || node.IsAbstract)
                        return null;

                    if (node.GetAttributes().Any(a => a.AttributeClass!.Name == DontRegisterAttribute) || node.AllInterfaces.Length == 0)
                        return null;

                    if (!node.AllInterfaces.Any(m => m.ToDisplayString() == "FastEndpoints.IEndpoint"))
                        return null;

                    var method = node.GetMembers().OfType<IMethodSymbol>().FirstOrDefault(m => m.Name is "HandleAsync" or "ExecuteAsync");
                    if (method is null)
                        return null;

                    if (!ContainsImplicitErrorSending(ctx.SemanticModel, method))
                        return null;

                    return node.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                })
            .Where(static m => m is not null)
            .Select(static (m, _) => m!)
            .WithTrackingName("ImplicitErrorSenders");

        var combinedProvider = implicitSendersProvider
            .Combine(assemblyProvider)
            .Collect()
            .WithTrackingName("Combination");

        context.RegisterSourceOutput(combinedProvider, GenerateCode);
    }

    private void GenerateCode(SourceProductionContext context, ImmutableArray<(string TypeName, string? AssemblyName)> implicitSenders)
    {
        if (!implicitSenders.Any())
        {
            return;
        }
        
        var asmName = implicitSenders[0].AssemblyName;
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();
        sb.Append("namespace ");
        sb.Append(asmName);
        sb.AppendLine(";");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine();
        sb.AppendLine("public static class ImplicitErrorSenders");
        sb.AppendLine("{");
        sb.AppendLine("    public static readonly FrozenSet<Type> Endpoints =");
        sb.AppendLine("        FrozenSet.ToFrozenSet([");
        foreach (var (type, _) in implicitSenders)
        {
            sb.Append("            typeof(");
            sb.Append(type);
            sb.AppendLine("),");
        }

        sb.AppendLine("        ]);");
        sb.Append("}");

        context.AddSource($"ImplicitErrorSenders.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
    
    // Searches methods (2 deep) for error sending mechanisms
    static bool ContainsImplicitErrorSending(SemanticModel model, IMethodSymbol method, int depth = 0)
    {
        const int maxDepth = 1;

        if (depth > maxDepth)
            return false;
        
        if (!(method.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() is MethodDeclarationSyntax syntax))
            return false;

        var syntaxNode = syntax.Body as CSharpSyntaxNode ?? syntax.ExpressionBody;

        if (syntaxNode is null)
            return false;
        
        var invocations = syntaxNode.DescendantNodes().OfType<InvocationExpressionSyntax>().ToArray();

        // Explicitly walked twice to prevent walking if a direct invocation is lower in the method
        var directInvocations = invocations.Any(i =>
        {
            var name = (i.Expression as MemberAccessExpressionSyntax)?.Name.ToString() ?? i.Expression.ToString();

            if (!ImplicitSenders.Contains(name)) return false;

            if (model.GetSymbolInfo(i).Symbol is not IMethodSymbol symbol)
                return false;
            
            var namespaceName = symbol.ContainingNamespace.ToDisplayString();
            return namespaceName == "FastEndpoints";
        });

        if (directInvocations)
            return true;

        // Micro-opt, don't walk just to be rejected
        if (depth == maxDepth)
            return false;
        
        return invocations.Any(i =>
        {
            if (model.GetSymbolInfo(i).Symbol is not IMethodSymbol symbol)
                return false;
            
            return ContainsImplicitErrorSending(model, symbol, depth + 1);
        });
    }
}